# app/repositories/session_context_repo.py
import asyncpg
from typing import List, Dict, Optional
from datetime import datetime, timedelta
import json

class SessionContextRepository:
    def __init__(self, conn: asyncpg.Connection):
        self.conn = conn

    async def create_session_context_table(self):
        """Cria tabela para armazenar contexto de sessão se não existir"""
        await self.conn.execute("""
            CREATE TABLE IF NOT EXISTS session_context (
                id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                usuario_id INT NOT NULL,
                sessao_id VARCHAR(255) UNIQUE NOT NULL,
                perfil_ativo_id INT NOT NULL,
                perfis_disponiveis JSONB NOT NULL,
                data_criacao TIMESTAMP DEFAULT NOW(),
                data_ultima_atividade TIMESTAMP DEFAULT NOW(),
                data_ultima_alternancia TIMESTAMP,
                ip_address INET,
                user_agent TEXT,
                ativo BOOLEAN DEFAULT TRUE,
                FOREIGN KEY (usuario_id) REFERENCES usuario(id),
                FOREIGN KEY (perfil_ativo_id) REFERENCES perfil(id)
            );
        """)
        
        await self.conn.execute("""
            CREATE INDEX IF NOT EXISTS idx_session_context_usuario_id 
            ON session_context(usuario_id) WHERE ativo = TRUE;
        """)
        
        await self.conn.execute("""
            CREATE INDEX IF NOT EXISTS idx_session_context_sessao_id 
            ON session_context(sessao_id) WHERE ativo = TRUE;
        """)

    async def create_profile_switch_history_table(self):
        """Cria tabela para histórico de alternância de perfis"""
        await self.conn.execute("""
            CREATE TABLE IF NOT EXISTS profile_switch_history (
                id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                usuario_id INT NOT NULL,
                sessao_id VARCHAR(255) NOT NULL,
                perfil_anterior_id INT NOT NULL,
                perfil_novo_id INT NOT NULL,
                data_alternancia TIMESTAMP DEFAULT NOW(),
                ip_address INET,
                user_agent TEXT,
                justificativa TEXT,
                FOREIGN KEY (usuario_id) REFERENCES usuario(id),
                FOREIGN KEY (perfil_anterior_id) REFERENCES perfil(id),
                FOREIGN KEY (perfil_novo_id) REFERENCES perfil(id)
            );
        """)

    async def create_session_context(self, usuario_id: int, sessao_id: str, 
                                   perfil_ativo_id: int, perfis_disponiveis: List[Dict],
                                   ip_address: Optional[str] = None, 
                                   user_agent: Optional[str] = None) -> Dict:
        """Cria um novo contexto de sessão"""
        await self.create_session_context_table()
        
        query = """
            INSERT INTO session_context 
            (usuario_id, sessao_id, perfil_ativo_id, perfis_disponiveis, ip_address, user_agent)
            VALUES ($1, $2, $3, $4, $5, $6)
            RETURNING *
        """
        
        record = await self.conn.fetchrow(
            query, usuario_id, sessao_id, perfil_ativo_id, 
            json.dumps(perfis_disponiveis), ip_address, user_agent
        )
        return dict(record)

    async def get_session_context(self, sessao_id: str) -> Optional[Dict]:
        """Busca contexto de sessão ativo"""
        query = """
            SELECT sc.*, u.nome as usuario_nome, p.nome as perfil_ativo_nome
            FROM session_context sc
            JOIN usuario u ON sc.usuario_id = u.id
            JOIN perfil p ON sc.perfil_ativo_id = p.id
            WHERE sc.sessao_id = $1 AND sc.ativo = TRUE
        """
        record = await self.conn.fetchrow(query, sessao_id)
        return dict(record) if record else None

    async def update_active_profile(self, sessao_id: str, novo_perfil_id: int,
                                  justificativa: Optional[str] = None,
                                  ip_address: Optional[str] = None,
                                  user_agent: Optional[str] = None) -> bool:
        """Atualiza o perfil ativo da sessão"""
        await self.create_profile_switch_history_table()
        
        # Busca contexto atual
        current_context = await self.get_session_context(sessao_id)
        if not current_context:
            return False
        
        # Registra histórico da alternância
        await self.conn.execute("""
            INSERT INTO profile_switch_history 
            (usuario_id, sessao_id, perfil_anterior_id, perfil_novo_id, 
             justificativa, ip_address, user_agent)
            VALUES ($1, $2, $3, $4, $5, $6, $7)
        """, current_context['usuario_id'], sessao_id, 
             current_context['perfil_ativo_id'], novo_perfil_id,
             justificativa, ip_address, user_agent)
        
        # Atualiza contexto atual
        result = await self.conn.execute("""
            UPDATE session_context 
            SET perfil_ativo_id = $1, 
                data_ultima_alternancia = NOW(),
                data_ultima_atividade = NOW()
            WHERE sessao_id = $2 AND ativo = TRUE
        """, novo_perfil_id, sessao_id)
        
        return result.endswith('1')

    async def update_last_activity(self, sessao_id: str) -> bool:
        """Atualiza timestamp da última atividade"""
        result = await self.conn.execute("""
            UPDATE session_context 
            SET data_ultima_atividade = NOW()
            WHERE sessao_id = $1 AND ativo = TRUE
        """, sessao_id)
        return result.endswith('1')

    async def get_user_active_sessions(self, usuario_id: int) -> List[Dict]:
        """Busca todas as sessões ativas de um usuário"""
        query = """
            SELECT sc.*, p.nome as perfil_ativo_nome
            FROM session_context sc
            JOIN perfil p ON sc.perfil_ativo_id = p.id
            WHERE sc.usuario_id = $1 AND sc.ativo = TRUE
            ORDER BY sc.data_ultima_atividade DESC
        """
        records = await self.conn.fetch(query, usuario_id)
        return [dict(r) for r in records]

    async def deactivate_session(self, sessao_id: str) -> bool:
        """Desativa uma sessão (logout)"""
        result = await self.conn.execute("""
            UPDATE session_context 
            SET ativo = FALSE 
            WHERE sessao_id = $1
        """, sessao_id)
        return result.endswith('1')

    async def cleanup_expired_sessions(self, hours: int = 24) -> int:
        """Remove sessões expiradas"""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        
        result = await self.conn.execute("""
            UPDATE session_context 
            SET ativo = FALSE 
            WHERE data_ultima_atividade < $1 AND ativo = TRUE
        """, cutoff_time)
        
        # Extrai número de linhas afetadas
        return int(result.split()[-1]) if result.split()[-1].isdigit() else 0

    async def get_profile_switch_history(self, usuario_id: int, limit: int = 50) -> List[Dict]:
        """Busca histórico de alternância de perfis do usuário"""
        query = """
            SELECT psh.*, 
                   p1.nome as perfil_anterior_nome,
                   p2.nome as perfil_novo_nome
            FROM profile_switch_history psh
            JOIN perfil p1 ON psh.perfil_anterior_id = p1.id
            JOIN perfil p2 ON psh.perfil_novo_id = p2.id
            WHERE psh.usuario_id = $1
            ORDER BY psh.data_alternancia DESC
            LIMIT $2
        """
        records = await self.conn.fetch(query, usuario_id, limit)
        return [dict(r) for r in records]

    async def validate_profile_for_user(self, usuario_id: int, perfil_id: int) -> bool:
        """Valida se o usuário pode usar um perfil específico"""
        query = """
            SELECT 1 FROM usuario_perfil up
            WHERE up.usuario_id = $1 AND up.perfil_id = $2 AND up.ativo = TRUE
        """
        result = await self.conn.fetchval(query, usuario_id, perfil_id)
        return bool(result)

    async def get_user_available_profiles(self, usuario_id: int) -> List[Dict]:
        """Busca todos os perfis disponíveis para o usuário"""
        query = """
            SELECT p.id, p.nome, 
                   CASE 
                       WHEN p.nome = 'Administrador' THEN 'Acesso total ao sistema'
                       WHEN p.nome = 'Gestor' THEN 'Gestão de contratos e equipes'
                       WHEN p.nome = 'Fiscal' THEN 'Fiscalização e relatórios'
                       ELSE 'Perfil do sistema'
                   END as descricao
            FROM usuario_perfil up
            JOIN perfil p ON up.perfil_id = p.id
            WHERE up.usuario_id = $1 AND up.ativo = TRUE AND p.ativo = TRUE
            ORDER BY 
                CASE p.nome 
                    WHEN 'Administrador' THEN 1
                    WHEN 'Gestor' THEN 2
                    WHEN 'Fiscal' THEN 3
                    ELSE 4
                END
        """
        records = await self.conn.fetch(query, usuario_id)
        return [dict(r) for r in records]